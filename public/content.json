{"meta":{"title":"Yet Another Open Source Blog by Badacadabra | Baptiste Vannesson","subtitle":"FLOSS enthusiast","description":"JavaScript, Vim and GNU/Linux for the win!","author":"Baptiste Vannesson","url":"https://badacadabra.github.io"},"pages":[{"title":"About","date":"2017-05-27T16:45:01.000Z","updated":"2017-06-05T13:32:21.020Z","comments":false,"path":"about/index.html","permalink":"https://badacadabra.github.io/about/index.html","excerpt":"","text":"console.log('Hello, World!'); I am Baptiste Vannesson (aka Badacadabra), a modest Internet citizen from France. As far as I can remember, I have always been driven by a devouring intellectual curiosity and, to some extent, obsessed by the Socratic paradox. I work hard everyday to escape the Plato’s cave, absorbing some drops from the vast ocean of human knowledge. Free/Libre and Open Source Software (FLOSS) is my religion. I do believe that proprietary licenses conflict with basic freedoms of the modern world. Let’s share software, my friends! On this blog, you will read technical articles; mainly about JavaScript, Vim and GNU/Linux. If you find articles helpful or if I make a mistake somewhere, feel free to comment. You can also follow me on social media because, if you are here, we probably have interests in common… This work is licensed under a Creative Commons Attribution 4.0 International License. exit 0"}],"posts":[{"title":"What if JavaScript was a Java scripting language?","slug":"What-if-JavaScript-was-a-Java-scripting-language","date":"2017-06-08T21:51:28.000Z","updated":"2017-06-09T17:28:00.392Z","comments":true,"path":"What-if-JavaScript-was-a-Java-scripting-language/","link":"","permalink":"https://badacadabra.github.io/What-if-JavaScript-was-a-Java-scripting-language/","excerpt":"Meanwhile, in a parallel universe… JavaScript is a scripting language for the Java Platform and JS scripts should strictly apply the key concepts of object-oriented programming (OOP). Our task is to model and implement a simple program that involves living beings. This is of course a vast topic and, for the sake of simplicity, we will not deal with peripheral concepts like generics, synchronized methods, collections or packages. This would bring us too far.","text":"Meanwhile, in a parallel universe… JavaScript is a scripting language for the Java Platform and JS scripts should strictly apply the key concepts of object-oriented programming (OOP). Our task is to model and implement a simple program that involves living beings. This is of course a vast topic and, for the sake of simplicity, we will not deal with peripheral concepts like generics, synchronized methods, collections or packages. This would bring us too far. InheritanceJava is a class-based language where inheritance is performed using the extends keyword. This is much more complicated in JavaScript… ES5ECMAScript 5 does not have built-in classes. JavaScript is a prototype-based language, but classes can be emulated thanks to constructor functions. Inheritance is possible, but should be done through a manipulation of prototypes: // Parent classfunction LivingBeing(species) &#123; // constructor this.species = species; // attribute&#125;LivingBeing.live = function() &#123; // static method return 'Life is life!';&#125;;// Child classfunction Person(firstname, lastname) &#123; // constructor LivingBeing.call(this, 'Homo sapiens'); // super(\"Homo sapiens\") this.firstname = firstname; // attribute this.lastname = lastname; // attribute&#125;// extendsPerson.prototype = Object.create(LivingBeing.prototype);Person.prototype.constructor = Person;Person.prototype.sayHello = function () &#123; // instance method return 'Hello, ' + this.firstname + ' ' + this.lastname + '!';&#125;;// --------------------var anonymousDog = new LivingBeing('Canis lupus');console.log(anonymousDog.species); // Canis lupusvar john = new Person('John', 'Doe');console.log(john.sayHello(), '(' + john.species + ')'); // Hello, John Doe! (Homo sapiens)console.log(LivingBeing.live()); // Life is life! ES6ECMAScript 6 brought syntactic sugar to work more easily with so-called classes and inheritance. This new syntax hides the true prototypal nature of JavaScript, but now the language looks much more familiar for Java developers: // Parent classclass LivingBeing &#123; constructor(species) &#123; this.species = species; // attribute &#125; static live() &#123; // static method return 'Life is life!'; &#125;&#125;// Child classclass Person extends LivingBeing &#123; constructor(firstname, lastname) &#123; super('Homo sapiens'); this.firstname = firstname; // attribute this.lastname = lastname; // attribute &#125; sayHello() &#123; // instance method return `Hello, $&#123;this.firstname&#125; $&#123;this.lastname&#125;!`; &#125;&#125;// --------------------let anonymousDog = new LivingBeing('Canis lupus');console.log(anonymousDog.species); // Canis lupuslet john = new Person('John', 'Doe');console.log(john.sayHello(), `($&#123;john.species&#125;)`); // Hello, John Doe! (Homo sapiens)console.log(LivingBeing.live()); // Life is life! CompositionIn OOP, a best practice is to favor composition over inheritance. ES5Composition in ECMAScript 5 is not so different from composition in Java. A specific class may reference another class using an instance of the latter in one of its properties. // Class to be referencedfunction LivingBeing(species) &#123; // constructor this.species = species; // attribute&#125;LivingBeing.live = function() &#123; // static method return 'Life is life!';&#125;;// Main classfunction Person(firstname, lastname) &#123; // constructor this.livingBeing = new LivingBeing('Homo sapiens'); // attribute (composition) this.firstname = firstname; // attribute this.lastname = lastname; // attribute&#125;Person.prototype.sayHello = function () &#123; // instance method return 'Hello, ' + this.firstname + ' ' + this.lastname + '!';&#125;;// --------------------var anonymousDog = new LivingBeing('Canis lupus');console.log(anonymousDog.species);var john = new Person('John', 'Doe');console.log(john.sayHello(), '(' + john.livingBeing.species + ')'); // Hello, John Doe! (Homo sapiens)console.log(LivingBeing.live()); // Life is life! ES6Composition in ECMAScript 6 is even closer to Java, thanks to the syntactic sugar that emulates classes natively: // Class to be referencedclass LivingBeing &#123; constructor(species) &#123; this.species = species; // attribute &#125; static live() &#123; return 'Life is life!'; &#125;&#125;// Main classclass Person &#123; constructor(firstname, lastname) &#123; this.livingBeing = new LivingBeing('Homo sapiens'); // attribute (composition) this.firstname = firstname; // attribute this.lastname = lastname; // attribute &#125; sayHello() &#123; return `Hello, $&#123;this.firstname&#125; $&#123;this.lastname&#125;!`; &#125;&#125;// --------------------let anonymousDog = new LivingBeing('Canis lupus');console.log(anonymousDog.species);let john = new Person('John', 'Doe');console.log(john.sayHello(), `($&#123;john.livingBeing.species&#125;)`); // Hello, John Doe (Homo sapiens)console.log(LivingBeing.live()); // Life is life! Composition works fine here, but conceptually, inheritance is more meaningful for this particular problem. AbstractionAbstraction in Java is based on abstract classes and interfaces. JavaScript does not have a built-in abstraction mechanism, but like classes in ES5, this concept can be emulated. Abstract classAn abstract class is a class that cannot be instantiated, so we cannot create direct objects from an abstract class. In JavaScript, we can prevent instantiation of a particular class using conditions in the constructor. An abstract class can contain abstract methods which are methods without implementation. In JavaScript, this can be reproduced quite easily if we declare a prototype method that only throws an error. It will remain “abstract” (it will throw an error) as long as it is not redefined in the prototype chain. ES5To create an abstract class in ES5 (here LivingBeing), the best test to check if the constructor has been called directly with new is this.constructor === LivingBeing. Be careful to use the right comparison operator because this.constructor !== LivingBeing would create (roughly) a final class (a class that cannot be extended)! // Abstract classfunction LivingBeing(species) &#123; if (this.constructor === LivingBeing) &#123; throw new Error('You cannot instantiate an abstract class!'); &#125; this.species = species;&#125;LivingBeing.prototype.communicate = function () &#123; // abstract method throw new Error('You cannot call an abstract method!');&#125;;// Concrete classfunction Person(firstname, lastname) &#123; LivingBeing.call(this, 'Homo sapiens'); this.firstname = firstname; this.lastname = lastname;&#125;Person.prototype = Object.create(LivingBeing.prototype);Person.prototype.constructor = Person;Person.prototype.sayHello = function () &#123; // concrete method return 'Hello, ' + this.firstname + ' ' + this.lastname + '!';&#125;;// --------------------var john = new Person('John', 'Doe');console.log(john.sayHello(), '(' + john.species + ')'); // Hello, John Doe! (Homo sapiens)john.communicate(); // Error: Your cannot call an abstract method!new LivingBeing('Canis lupus'); // Error: You cannot instantiate an abstract class! ES6With ES6, it is better to use new.target like this: new.target.name === &#39;LivingBeing&#39;. Once again, be careful with the comparison operator: new.target.name !== &#39;LivingBeing&#39; would create a final class. // Abstract classclass LivingBeing &#123; constructor(species) &#123; if (new.target.name === 'LivingBeing') &#123; throw new Error('You cannot instantiate an abstract class!'); &#125; this.species = species; &#125; communicate() &#123; // abstract method throw new Error('You cannot call an abstract method!'); &#125;&#125;// Concrete classclass Person extends LivingBeing &#123; constructor(firstname, lastname) &#123; super('Homo sapiens'); this.firstname = firstname; this.lastname = lastname; &#125; sayHello() &#123; // concrete method return `Hello, $&#123;this.firstname&#125; $&#123;this.lastname&#125;`; &#125;&#125;// --------------------let john = new Person('John', 'Doe');console.log(john.sayHello(), `($&#123;john.species&#125;)`); // Hello, John Doe! (Homo sapiens)john.communicate(); // Error: You cannot call an abstract method!new LivingBeing('Canis lupus'); // Error: You cannot instantiate an abstract class! InterfaceInterfaces in Java are quite close to 100% abstract classes. They contain public abstract methods that must be overriden in classes which implement them. ES5A solution to get interfaces in ES5 is to create a custom implements function in Function.prototype and use object literals to declare interfaces. The custom function must traverse the own properties of the interface passed as an argument and test if they exist in the current function instance (presumably a constructor function). If they do not exist, they should be created in the function’s prototype. In this case, they remain abstract, meaning that they will throw an error if we try to use them before to override them. // Custom \"implements\" functionFunction.prototype.implements = function (iface) &#123; if (iface.toString() !== '[object Object]') &#123; throw new Error('Invalid argument. An interface must be an object.'); &#125; else &#123; for (var prop in iface) &#123; if (iface.hasOwnProperty(prop)) &#123; if (typeof iface[prop] === 'function' &amp;&amp; !(prop in this)) &#123; this.prototype[prop] = iface[prop]; &#125; &#125; &#125; &#125;&#125;;// Interfacevar LivingBeingInterface = &#123; communicate: function () &#123; throw new Error('You cannot call an abstract method!'); &#125;, getSpecies: function () &#123; throw new Error('You cannot call an abstract method!'); &#125;&#125;;// ClassPerson.implements(LivingBeingInterface); // cool, isn't it?function Person(firstname, lastname) &#123; this.firstname = firstname; this.lastname = lastname; this.species = 'Homo sapiens';&#125;Person.prototype.sayHello = function () &#123; return 'Hello, ' + this.firstname + ' ' + this.lastname + '!';&#125;;Person.prototype.communicate = function () &#123; // overrides the default implementation return 'blah blah blah';&#125;;// Person.prototype.getSpecies() is not overriden// --------------------var john = new Person('John', 'Doe');console.log(john.sayHello()); // Hello, John Doe!console.log(john.communicate()); // blah blah blahconsole.log(john.getSpecies()); // Error: You cannot call an abstract method! ES6ES6 classes are like coherent blocks of methods and they are not hoisted. Thus, contrary to ES5, we must call our implements method after the class declaration. // Custom \"implements\" functionFunction.prototype.implements = function (iface) &#123; if (iface.toString() !== '[object Object]') &#123; throw new Error('Invalid argument. An interface must be an object.'); &#125; else &#123; for (let prop in iface) &#123; if (iface.hasOwnProperty(prop)) &#123; if (typeof iface[prop] === 'function' &amp;&amp; !(prop in this.prototype)) &#123; this.prototype[prop] = iface[prop]; &#125; &#125; &#125; &#125;&#125;;// Interfaceconst LivingBeingInterface = &#123; communicate() &#123; throw new Error('You cannot call an abstract method!'); &#125;, getSpecies() &#123; throw new Error('You cannot call an abstract method!'); &#125;&#125;;// Classclass Person &#123; constructor (firstname, lastname) &#123; this.firstname = firstname; this.lastname = lastname; this.species = 'Homo sapiens'; &#125; sayHello() &#123; return `Hello, $&#123;this.firstname&#125; $&#123;this.lastname&#125;!`; &#125; communicate() &#123; // overrides the default implementation return 'blah blah blah'; &#125; // Person.prototype.getSpecies() is not overriden&#125;Person.implements(LivingBeingInterface); // cool, isn't it?// --------------------let john = new Person('John', 'Doe');console.log(john.sayHello()); // Hello, John Doe!console.log(john.communicate()); // blah blah blahconsole.log(john.getSpecies()); // Error: You cannot call an abstract method! PolymorphismAs you may know, Java is strongly typed. On the contrary, JavaScript is loosely typed. But, in Java, if you create an instance of Person that extends LivingBeing, this instance is of type Person and LivingBeing. So if you iterate through a collection of LivingBeing objects containing people, animals or plants, and call the same method on each object, you will have specific results for each living being thanks to a dynamic binding. JavaScript works this way too if we use the prototype chain properly. ES5As an example, we could override the original Object.prototype.toString() method for people and dogs. In JavaScript, classes and their instances are objects. By default, when we call toString() on an object, we get [object Object]. Person or Dog instances are also indirect instances of LivingBeing, so we could define several toString() methods in the prototype chain. function LivingBeing(species) &#123; if (this.constructor === LivingBeing) &#123; throw new Error('You cannot instantiate an abstract class!'); &#125; this.species = species;&#125;// Overrides Object.prototype.toString()LivingBeing.prototype.toString = function () &#123; // returns the species instead of [object Object] return 'Species: ' + this.species;&#125;;function Person(firstname, lastname) &#123; LivingBeing.call(this, 'Homo sapiens'); this.firstname = firstname; this.lastname = lastname;&#125;Person.prototype = Object.create(LivingBeing.prototype);Person.prototype.constructor = Person;Person.prototype.sayHello = function () &#123; return 'Hello, ' + this.firstname + ' ' + this.lastname + '!';&#125;;// Overrides LivingBeing.prototype.toString()Person.prototype.toString = function () &#123; var str = '\\n'; str += 'First name: ' + this.firstname + '\\n'; str += 'Last name: ' + this.lastname + '\\n'; str += LivingBeing.prototype.toString.call(this); // super.toString() return str; // returns a summary instead of the species&#125;;function Dog(name) &#123; LivingBeing.call(this, 'Canis lupus'); this.name = name;&#125;// Overrides LivingBeing.prototype.toString()Dog.prototype.toString = function () &#123; var str = '\\n'; str += 'Name: ' + this.name + '\\n'; str += LivingBeing.prototype.toString.call(this); return str; // returns a summary instead of the species&#125;;// --------------------var john = new Person('John', 'Doe');console.log(john.sayHello(), '(' + john.species + ')'); // Hello, John Doe! (Homo sapiens)var fido = new Dog('Fido');console.log(fido.name, '(' + fido.species + ')'); // Fido (Canis lupus)var livingBeings = [john, fido];for (var i = 0; i &lt; livingBeings.length; i++) &#123; console.log(livingBeings[i].toString());&#125;// First name: John// Last name: Doe// Species: Homo sapiens// Name: Fido// Species: Canis lupus ES6It is not so different with ES6, except that we can use classes, string interpolation and a for...of loop for convenience: class LivingBeing &#123; constructor(species) &#123; if (new.target.name === 'LivingBeing') &#123; throw new Error('You cannot instantiate an abstract class!'); &#125; this.species = species; &#125; toString() &#123; // overrides Object.prototype.toString() // returns the species instead of [object Object] return `Species: $&#123;this.species&#125;`; &#125;&#125;class Person extends LivingBeing &#123; constructor(firstname, lastname) &#123; super('Homo sapiens'); this.firstname = firstname; this.lastname = lastname; &#125; sayHello() &#123; return `Hello, $&#123;this.firstname&#125; $&#123;this.lastname&#125;!`; &#125; toString() &#123; // overrides LivingBeing.prototype.toString() return `First name: $&#123;this.firstname&#125;Last name: $&#123;this.lastname&#125;$&#123;super.toString()&#125;`; // returns a summary instead of the species &#125;&#125;class Dog extends LivingBeing &#123; constructor(name) &#123; super('Canis lupus'); this.name = name; &#125; toString() &#123; // overrides LivingBeing.prototype.toString() return `Name: $&#123;this.name&#125;$&#123;super.toString()&#125;`; // returns a summary instead of the species &#125;&#125;// --------------------let john = new Person('John', 'Doe');console.log(john.sayHello(), `($&#123;john.species&#125;)`); // Hello, John Doe! (Homo sapiens)let fido = new Dog('Fido');console.log(fido.name, `($&#123;fido.species&#125;)`); // Fido (Canis lupus)let livingBeings = [john, fido];for (const being of livingBeings) &#123; console.log(being.toString());&#125;// First name: John// Last name: Doe// Species: Homo sapiens// Name: Fido// Species: Canis lupus EncapsulationEncapsulation makes it possible to restrict the access to class members through access level modifiers and getters/setters. Access level modifiersJava provides useful keywords like public, protected or private to modify access level of class attributes and methods. Unfortunately, JavaScript does not have these access modifiers (they are reserved words but are still unused). ES5To reproduce the effect of public, protected or private, we have to play with the scope chain, closures and IIFEs (Immediately-Invoked Function Expressions). A public member is basically a prototype property. A protected member is a simple variable or function declared inside a surrounding function and that can be accessed from LivingBeing and Person. A private member is a simple variable or function declared inside a nested function and that can be accessed from Person only. var Person = (function () &#123; // public class var species = ''; // protected attribute function LivingBeing(s) &#123; // protected inner class species = s; &#125; var Person = (function () &#123; var firstname = '', // private attribute lastname = ''; // private attribute function Person(first, last) &#123; // private inner class LivingBeing.call(this, 'Homo sapiens'); firstname = first; lastname = last; &#125; Person.prototype = Object.create(LivingBeing.prototype); Person.prototype.constructor = Person; Person.prototype.sayHello = function () &#123; // public method return 'Hello, ' + firstname + ' ' + lastname + '! (' + species + ')'; &#125;; return Person; &#125;)(); return Person;&#125;)();// --------------------var john = new Person('John', 'Doe');console.log(john.sayHello()); // Hello, John Doe! (Homo sapiens)console.log(john.firstname, john.lastname, john.species); // undefined undefined undefined ES6It may be surprising, but ES6 classes do not even have access level modifiers. Here we can use arrow functions for convenience: const Person = (() =&gt; &#123; // public class let species = ''; // protected attribute class LivingBeing &#123; // protected inner class constructor(s) &#123; species = s; &#125; &#125; const Person = (() =&gt; &#123; let firstname = '', // private attribute lastname = ''; // private attribute class Person extends LivingBeing &#123; // private inner class constructor (first, last) &#123; super('Homo sapiens'); firstname = first; lastname = last; &#125; sayHello() &#123; // public method return `Hello, $&#123;firstname&#125; $&#123;lastname&#125;! ($&#123;species&#125;)`; &#125; &#125; return Person; &#125;)(); return Person;&#125;)();// --------------------let john = new Person('John', 'Doe');console.log(john.sayHello()); // Hello, John Doe! (Homo sapiens)console.log(john.firstname, john.lastname, john.species); // undefined undefined undefined Getters/SettersWhen some fields are private or protected, they cannot be accessed from the outside. To read them or modify them, we need public methods: getters and setters. ES5Getters and setters can be defined with the old (now deprecated) __defineGetter__ or __defineSetter__ respectively, but this is much better to create a regular function with get or set in the name. var Person = (function () &#123; // public class var species = ''; // protected attribute function LivingBeing(s) &#123; // protected inner class species = s; &#125; LivingBeing.prototype.getSpecies = function () &#123; // public getter return species; &#125;; LivingBeing.prototype.setSpecies = function (s) &#123; // public setter species = s; &#125;; var Person = (function () &#123; var firstname = '', // private attribute lastname = ''; // private attribute function Person(first, last) &#123; // private inner class LivingBeing.call(this, 'Homo sapiens'); firstname = first; lastname = last; &#125; Person.prototype = Object.create(LivingBeing.prototype); Person.prototype.constructor = Person; Person.prototype.sayHello = function () &#123; // public method return 'Hello, ' + firstname + ' ' + lastname + '! (' + species + ')'; &#125;; Person.prototype.getFirstname = function () &#123; // public getter return firstname; &#125;; Person.prototype.setFirstname = function (first) &#123; // public setter firstname = first; &#125;; Person.prototype.getLastname = function () &#123; // public getter return lastname; &#125;; Person.prototype.setLastname = function (last) &#123; // public setter lastname = last; &#125;; return Person; &#125;)(); return Person;&#125;)();var john = new Person('John', 'Doe');console.log(john.sayHello()); // Hello, John Doe! (Homo sapiens)console.log(john.getFirstname(), john.getLastname(), '(' + john.getSpecies() + ')'); // John Doe (Homo sapiens)john.setFirstname('Jane');console.log(john.getFirstname(), john.getLastname()); // Jane Doe ES6get and set keywords, which were available in ES5 object literals, are now available in ES6 classes. They can be used like so: const Person = (() =&gt; &#123; // public class let species = ''; // protected attribute // Abstract class class LivingBeing &#123; // protected inner class constructor(s) &#123; species = s; &#125; get species() &#123; // public getter return species; &#125; set species(s) &#123; // public setter species = s; &#125; &#125; // Concrete class const Person = (() =&gt; &#123; let firstname = '', // private attribute lastname = ''; // private attribute class Person extends LivingBeing &#123; // private inner class constructor (first, last) &#123; super('Homo sapiens'); firstname = first; lastname = last; &#125; sayHello() &#123; // public method return `Hello, $&#123;firstname&#125; $&#123;lastname&#125;! ($&#123;species&#125;)`; &#125; get firstname() &#123; // public getter return firstname; &#125; set firstname(first) &#123; // public setter firstname = first; &#125; get lastname() &#123; // public getter return lastname; &#125; set lastname(last) &#123; // public setter lastname = last; &#125; &#125; return Person; &#125;)(); return Person;&#125;)();let john = new Person('John', 'Doe');console.log(john.sayHello()); // Hello, John Doe! (Homo sapiens)console.log(john.firstname, john.lastname, `($&#123;john.species&#125;)`); // John Doe (Homo sapiens)john.firstname = 'Jane';console.log(john.firstname, john.lastname); // Jane Doe Back to realityJavaScript is NOT Java. Trying to imitate Java with JavaScript is not necessarily a good idea in real life, but this is extremely interesting for educational purposes. JavaScript is an object-oriented language (in spite of its prototypal nature), but it is much more flexible and permissive than Java. It does not matter if you do not have a strict class hierarchy. It does not matter if you do not have abstraction. It does not even matter if you do not have a strict encapsulation. For Java developers who really want to feel at home with JavaScript, use TypeScript.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://badacadabra.github.io/categories/JavaScript/"}],"tags":[{"name":"ES5","slug":"ES5","permalink":"https://badacadabra.github.io/tags/ES5/"},{"name":"OOP","slug":"OOP","permalink":"https://badacadabra.github.io/tags/OOP/"},{"name":"ES6","slug":"ES6","permalink":"https://badacadabra.github.io/tags/ES6/"}]},{"title":"Building a visual form in your terminal emulator with Blessed","slug":"Building-a-visual-form-in-your-terminal-emulator-with-Blessed","date":"2017-06-05T21:52:43.000Z","updated":"2017-06-07T21:35:00.973Z","comments":true,"path":"Building-a-visual-form-in-your-terminal-emulator-with-Blessed/","link":"","permalink":"https://badacadabra.github.io/Building-a-visual-form-in-your-terminal-emulator-with-Blessed/","excerpt":"Do you like ncurses? Do you like JavaScript? If yes, you will love Blessed; a Node.js library to create highly interactive and rich text-based user interfaces.","text":"Do you like ncurses? Do you like JavaScript? If yes, you will love Blessed; a Node.js library to create highly interactive and rich text-based user interfaces. GUI vs CLI vs TUIGraphical User Interfaces (GUIs) are great in terms of design and usability, but they are quite poor when it comes to automation and performance. For complex operations, it is much easier to write a shell script with Bash than programming macros to interact with graphical components. Of course, sometimes we have to test GUIs. But do we need to automate heavy ones when we just want to manipulate files and perform basic operations? The answer is obviously NO. However, a Command Line Interface (CLI) is not very user-friendly. For this reason, we might need a better interface, without sacrificing too much performance. Here comes the Text-based User Interface (TUI)… The principle is simple: we are still in a terminal, we are still in a textual environment, but here we can create visual layouts using widgets. Graphical components are lightweight and can be used to reproduce layouts we can find on most desktop or web applications. SpecificationsLet’s say we want to get some information about a user. We need to know: The full name (first name + last name) of the user His favorite text editors among “Vim”, “Emacs”, “Atom” and “Brackets” If he likes Blessed or not If he has some comments to share Basic CLI implementation with BashTo get user input, we can create a Bash script and use the read command. A possible (but very basic) implementation could look like this: #!/bin/bashecho -e \"\\033[0;34mFirst name:\\033[0m\"read -r firstnameecho -e \"\\033[0;34mLast name:\\033[0m\"read -r lastnameecho -e \"\\033[0;34mWhat are your favorite editors? (enter numbers only) 1) Vim 2) Emacs 3) Atom 4) Brackets\\033[0m\"read -r selectioneditors=\"\"if [[ \"$selection\" =~ ^.*1.*$ ]]; then editors+=\"Vim \"; fiif [[ \"$selection\" =~ ^.*2.*$ ]]; then editors+=\"Emacs \"; fiif [[ \"$selection\" =~ ^.*3.*$ ]]; then editors+=\"Atom \"; fiif [[ \"$selection\" =~ ^.*4.*$ ]]; then editors+=\"Brackets \"; fiecho -e \"\\033[0;34mDo you like Blessed? (y/n)\\033[0m\"read -r blessedecho -e \"\\033[0;34mYour comments...\\033[0m\"read -r commentsecho \"$firstname $lastname--------------------------Favorite editors: $editorsLikes Blessed: $blessedComments: $comments\" &gt; data.txt If I run the script and provide all relevant information, a data.txt file is generated with the following content: Baptiste Vannesson--------------------------Favorite editors: Vim Atom Likes Blessed: yComments: It works! This solution is acceptable if we do not need a sophisticated interface. But to shine in society, we may need something more advanced… Blessed comes to the rescue! Advanced TUI implementation with BlessedHere is the layout we are going to build programmatically: Importing modulesHere we use the CommonJS syntax. We need two modules only: blessed and fs. var blessed = require('blessed'), fs = require('fs'); Creating a screen objectJust like the scene in three.js, we need a primary object to render something on screen. With Blessed, this is easy to memorize because it is actually the screen object (which has a render() method). The following code creates a screen object called “Blessed form” with smart CSR (change-scroll-region) for a more efficient rendering: var screen = blessed.screen(&#123; smartCSR: true, title: 'Blessed form'&#125;); Because we are building a TUI, we can set global key bindings to interact more easily with our interface. A must-have is a shortcut that allows us to quit instead of killing the current shell session. By convention, we will press Q to quit: screen.key('q', function () &#123; this.destroy();&#125;); Configuring widgetsCreating user interfaces with Blessed is not very hard, but extremely verbose and declarative. The library makes an intensive use of the object specifier pattern (aka options object). It sometimes happens that a constructor is given a very large number of parameters. This can be troublesome because it can be very difficult to remember the order of the arguments. In such cases, it can be much friendlier if we write the constructor to accept a single object specifier instead. That object contains the specification of the object to be constructed. Douglas Crockford, JavaScript: The Good Parts In fact, Blessed is based on widgets (text inputs, checkboxes, radio buttons, etc.) that can be configured quite precisely. As an example, here we create the form and its first text box: var form = blessed.form(&#123; parent: screen, width: '90%', left: 'center', keys: true, vi: true&#125;);var label = blessed.text(&#123; parent: screen, top: 3, left: 5, content: 'FIRST NAME:'&#125;);var firstName = blessed.textbox(&#123; parent: form, name: 'firstname', top: 4, left: 5, height: 3, inputOnFocus: true, content: 'first', border: &#123; type: 'line' &#125;, focus: &#123; fg: 'blue' &#125;&#125;); Blessed positioning is a bit less convenient and powerful than CSS positioning, but we do not have the same constraints for a web page and a terminal app. For a TUI, absolute positioning does the job quite well… Handling eventsTo submit or reset the form, we have two main buttons: submit &amp; reset. These buttons must trigger the appropriate form action. It could be done like so: submit.on('press', function () &#123; form.submit();&#125;);reset.on('press', function () &#123; form.reset();&#125;); When the form is submitted, we have to parse its data properly and write the result to a file. When it is reset, we just send a message (a toast): form.on('submit', function (data) &#123; // Checkboxes return an array of booleans like [true, false, true, false] var editors = ['Vim', 'Emacs', 'Atom', 'Brackets'].filter(function (item, index) &#123; return data.editors[index]; &#125;); msg.display('Form submitted!', function () &#123; var summary = ''; summary += data.firstname + ' ' + data.lastname + '\\n'; summary += '------------------------------\\n'; summary += 'Favorite editors: ' + editors + '\\n'; summary += 'Likes Blessed: ' + data.like[0] + '\\n'; summary += 'Comments: ' + data.comments; fs.writeFile('form-data.txt', summary, function (err) &#123; if (err) throw err; &#125;); &#125;);&#125;);form.on('reset', function () &#123; msg.display('Form cleared!', function () &#123;&#125;);&#125;); Done! Full implementationIf your environment is properly set up, you can run the following script with node: var blessed = require('blessed'), fs = require('fs');// Screenvar screen = blessed.screen(&#123; smartCSR: true, title: 'Blessed form'&#125;);// Formvar form = blessed.form(&#123; parent: screen, width: '90%', left: 'center', keys: true, vi: true&#125;);// Text boxesvar label1 = blessed.text(&#123; parent: screen, top: 3, left: 5, content: 'FIRST NAME:'&#125;);var firstName = blessed.textbox(&#123; parent: form, name: 'firstname', top: 4, left: 5, height: 3, inputOnFocus: true, content: 'first', border: &#123; type: 'line' &#125;, focus: &#123; fg: 'blue' &#125;&#125;);var label2 = blessed.text(&#123; parent: screen, content: 'LAST NAME:', top: 8, left: 5&#125;);var lastName = blessed.textbox(&#123; parent: form, name: 'lastname', top: 9, left: 5, height: 3, inputOnFocus: true, content: 'last', border: &#123; type: 'line' &#125;, focus: &#123; fg: 'blue' &#125;&#125;);// Check boxesvar label3 = blessed.text(&#123; parent: screen, content: 'What are your favorite editors?', top: 14, left: 5&#125;);var vim = blessed.checkbox(&#123; parent: form, name: 'editors', content: 'Vim', top: 16, left: 5&#125;);var emacs = blessed.checkbox(&#123; parent: form, name: 'editors', content: 'Emacs', top: 16, left: 20&#125;);var atom = blessed.checkbox(&#123; parent: form, name: 'editors', content: 'Atom', top: 16, left: 35&#125;);var brackets = blessed.checkbox(&#123; parent: form, name: 'editors', content: 'Brackets', top: 16, left: 50&#125;);// Radio buttonsvar label4 = blessed.text(&#123; parent: screen, content: 'Do you like Blessed?', top: 19, left: 5&#125;);var radioset = blessed.radioset(&#123; parent: form, width: '100%', height: 5, top: 21&#125;);var yes = blessed.radiobutton(&#123; parent: radioset, name: 'like', content: 'Yes', left: 5&#125;);var no = blessed.radiobutton(&#123; parent: radioset, name: 'like', content: 'No', left: 15&#125;);// Text areavar label5 = blessed.text(&#123; parent: screen, content: 'Your comments...', top: 24, left: 5&#125;);var textarea = blessed.textarea(&#123; parent: form, name: 'comments', top: 26, left: 5, height: 7, inputOnFocus: true, border: &#123; type: 'line' &#125;&#125;);// Submit/Cancel buttonsvar submit = blessed.button(&#123; parent: form, name: 'submit', content: 'Submit', top: 35, left: 5, shrink: true, padding: &#123; top: 1, right: 2, bottom: 1, left: 2 &#125;, style: &#123; bold: true, fg: 'white', bg: 'green', focus: &#123; inverse: true &#125; &#125;&#125;);var reset = blessed.button(&#123; parent: form, name: 'reset', content: 'Reset', top: 35, left: 15, shrink: true, padding: &#123; top: 1, right: 2, bottom: 1, left: 2 &#125;, style: &#123; bold: true, fg: 'white', bg: 'red', focus: &#123; inverse: true &#125; &#125;&#125;);// Infovar msg = blessed.message(&#123; parent: screen, top: 40, left: 5, style: &#123; italic: true, fg: 'green' &#125;&#125;);var table = blessed.table(&#123; parent: screen, content: '', top: 40, left: 'center', style: &#123; fg: 'green', header: &#123; bold: true, fg: 'white', bg: 'blue' &#125; &#125;, hidden: true&#125;);// Event managementsubmit.on('press', function () &#123; form.submit();&#125;);reset.on('press', function () &#123; form.reset();&#125;);form.on('submit', function (data) &#123; var editors = ['Vim', 'Emacs', 'Atom', 'Brackets'].filter(function (item, index) &#123; return data.editors[index]; &#125;); msg.display('Form submitted!', function () &#123; var summary = ''; summary += data.firstname + ' ' + data.lastname + '\\n'; summary += '------------------------------\\n'; summary += 'Favorite editors: ' + editors + '\\n'; summary += 'Likes Blessed: ' + data.like[0] + '\\n'; summary += 'Comments: ' + data.comments; fs.writeFile('form-data.txt', summary, function (err) &#123; if (err) throw err; &#125;); &#125;);&#125;);form.on('reset', function () &#123; msg.display('Form cleared!', function () &#123;&#125;);&#125;);// Key bindingsscreen.key('q', function () &#123; this.destroy();&#125;);// Render everything!screen.render(); ConclusionBuilding an advanced TUI may be a long process. Sometimes a raw CLI program is better, but if usability really matters, Blessed can be an interesting option and a good alternative to ncurses. By the way, in the use case presented here, there is no validation at all: not in our Bash script, nor in our Blessed script. If you want a good exercise, maybe you can try to implement it…","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://badacadabra.github.io/categories/JavaScript/"}],"tags":[{"name":"Blessed","slug":"Blessed","permalink":"https://badacadabra.github.io/tags/Blessed/"},{"name":"Node.js","slug":"Node-js","permalink":"https://badacadabra.github.io/tags/Node-js/"},{"name":"ES5","slug":"ES5","permalink":"https://badacadabra.github.io/tags/ES5/"}]},{"title":"Scraping a Ghost blog with PhantomJS and SlimerJS using CasperJS","slug":"Scraping-a-Ghost-blog-with-PhantomJS-and-SlimerJS-using-CasperJS","date":"2017-06-03T00:19:49.000Z","updated":"2017-06-07T00:49:32.763Z","comments":true,"path":"Scraping-a-Ghost-blog-with-PhantomJS-and-SlimerJS-using-CasperJS/","link":"","permalink":"https://badacadabra.github.io/Scraping-a-Ghost-blog-with-PhantomJS-and-SlimerJS-using-CasperJS/","excerpt":"This blog post will haunt your computer forever. You have been warned! :D In this article, we are going to present different techniques to scrape a Ghost blog (especially with the default Casper theme). We will use CasperJS, which is a scripting utility for PhantomJS (WebKit headless browser) and SlimerJS (Gecko minimalist GUI browser).","text":"This blog post will haunt your computer forever. You have been warned! :D In this article, we are going to present different techniques to scrape a Ghost blog (especially with the default Casper theme). We will use CasperJS, which is a scripting utility for PhantomJS (WebKit headless browser) and SlimerJS (Gecko minimalist GUI browser). Installation PhantomJS: npm i -g phantomjs-prebuilt SlimerJS: npm i -g slimerjs CasperJS: npm i -g casperjs The basicsA regular CasperJS script is composed of steps and has the following structure: var casper = require('casper').create();casper.start('http://www.website.com');casper.then(function () &#123; // Do something...&#125;);casper.run(); Casper.prototype defines lots of useful methods to interact with webpages and the most powerful one is probably evaluate() that gives a direct access to the DOM… Printing a list of the latest articles to consoleOK, so… Let’s take my personal blog in French as an example. In the following script (ghost.js), we get a list of the latest articles (these ones are displayed on the homepage): var casper = require('casper').create();// Tell CasperJS to visit the homepagecasper.start('http://blog.badacadabra.net');// Wait for articles to be loadedcasper.waitForSelector('article', function () &#123; this.echo('BLOG TITLE:\\n' + this.getTitle()); this.echo('\\nLATEST ARTICLES:'); // Each title in the \"titles\" array returned by \"evaluate\"... this.each(this.evaluate(function () &#123; var articles = document.querySelectorAll('article'), titles = []; for (var i = 0; i &lt; articles.length; i++) &#123; titles.push(articles[i].querySelector('.post-title').textContent); &#125; return titles; &#125;), function (self, title) &#123; // ... should be displayed in console! this.echo(title); &#125;);&#125;);casper.run(); To run the script: PhantomJS: casperjs ghost.js SlimerJS: casperjs --engine=slimerjs ghost.js Here is the output: BLOG TITLE:Hocus Pocus Numericus | Blog de Baptiste Vannesson (Badacadabra)LATEST ARTICLES:Les robots ont-ils des droits ?Stress, anxiété et phobies à l&apos;ère du numériqueLe règne de l&apos;autodidaxieLes limites du transhumanismeL&apos;ambiguïté du référencement payant So far, so good! But what if we want to get a full list of all articles? Printing a list of all published articles to consoleAn elegant solution to achieve this goal is to use recursion. Our scraper starts on the homepage, tests if there are older posts (using pagination as a reference), and goes from page to page thanks to an IIFE (Immediately-Invoked Function Expression) which calls itself. var casper = require('casper').create();casper.start('http://blog.badacadabra.net');casper.then(function () &#123; this.echo('BLOG TITLE:\\n' + this.getTitle()); this.echo('\\nLATEST ARTICLES:');&#125;);// Recursive IIFE(function getPostTitles() &#123; casper.waitForSelector('article', function () &#123; this.each(this.evaluate(function () &#123; var articles = document.querySelectorAll('article'), titles = []; for (var i = 0; i &lt; articles.length; i++) &#123; titles.push(articles[i].querySelector('.post-title').textContent); &#125; return titles; &#125;), function (self, title) &#123; this.echo(title); &#125;); &#125;); casper.then(function () &#123; // If the link to older posts is present in pagination, ... if (this.visible('.older-posts')) &#123; // ... click it to go to the next page, ... this.click('.older-posts'); // ... then run the same operations on this new page getPostTitles(); &#125; &#125;);&#125;)();casper.run(); Cool! Getting lists of headlines is funny, but is it really useful? RSS feed readers already do this for us without efforts. Would it not be more interesting to extract all articles and create appropriate files to store local copies automatically? Let’s do this right now! Extracting all articles to save local copies in filesystemExtracting all articles is not so easy without a clear methodology. Our script should: Start on the homepage Visit the first article Extract this article Go back to the homepage Visit the second article … Go to the next page Visit the first article of this page … End when the last article from the last page has been extracted It would be easy to define an array of predefined URLs, but this is not what we are going to do. This solution is not viable because each new article would not be taken into account by our script. In fact, we have to simulate the behavior of a user who would click each article in sequence to download all blog posts. Here we will need to interact with the filesystem, so the fs module is required. For this script, we keep the recursive IIFE: var casper = require('casper').create(), fs = require('fs');casper.start('http://blog.badacadabra.net');var index = 1, // index of the article in the current page content = ''; // textual content of the latest extracted article(function getPostContent() &#123; // Wait for articles to be loaded casper.waitForSelector('article', function () &#123; // Click the first link (the index starts at 1) this.click('.post:nth-of-type(' + index + ') a'); &#125;); casper.then(function () &#123; // Extract the textual content of the article content = this.evaluate(function () &#123; return document.querySelector('.post').textContent; &#125;); &#125;); casper.then(function () &#123; var title = this.getTitle(); this.echo('EXTRACTING - ' + title); // Process the title string to create a decent filename title = title.replace(/[ '\",]/g, '-').toLowerCase(); // Write the file to disk fs.write('articles/' + title, content, 'w'); // Go back to the homepage this.back(); &#125;); casper.waitForSelector('article', function () &#123; index++; // If there is another article on this page, get its content if (this.visible('.post:nth-of-type(' + index + ')')) &#123; getPostContent(); &#125; else &#123; // If not, continue on the next page (if there is one) if (this.visible('.older-posts')) &#123; index = 1; this.click('.older-posts'); getPostContent(); &#125; &#125; &#125;);&#125;)();casper.run(); Done! This script will create a local articles/ directory containing articles/files with raw textual content. ConclusionCasperJS is a powerful automation library on top of PhantomJS and SlimerJS. Moreover, thanks to a clean HTML code, a Ghost blog is a pleasure to scrape! If you want to learn more about these amazing technologies, maybe you can try to scrape articles filtered by author, by tag or by date… This is not very difficult with the code provided here, but this is a good exercise. You may also be interested in the Ghost API. Spectres have never been so kind!","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://badacadabra.github.io/categories/JavaScript/"}],"tags":[{"name":"ES5","slug":"ES5","permalink":"https://badacadabra.github.io/tags/ES5/"},{"name":"Ghost","slug":"Ghost","permalink":"https://badacadabra.github.io/tags/Ghost/"},{"name":"PhantomJS","slug":"PhantomJS","permalink":"https://badacadabra.github.io/tags/PhantomJS/"},{"name":"SlimerJS","slug":"SlimerJS","permalink":"https://badacadabra.github.io/tags/SlimerJS/"},{"name":"CasperJS","slug":"CasperJS","permalink":"https://badacadabra.github.io/tags/CasperJS/"}]},{"title":"Understanding JSFuck","slug":"Understanding-JSFuck","date":"2017-05-31T23:36:53.000Z","updated":"2017-06-07T00:49:01.157Z","comments":true,"path":"Understanding-JSFuck/","link":"","permalink":"https://badacadabra.github.io/Understanding-JSFuck/","excerpt":"JavaScript: The Good Parts readers and Douglas Crockford fans know that JavaScript subsets matter. Due to the permissive and versatile nature of the language, it is reasonable to select only the most solid stones to build a wall. But hey, why would we need to bother with a full programming language when we just need 6 characters? Here comes JSFuck by Martin Kleppe…","text":"JavaScript: The Good Parts readers and Douglas Crockford fans know that JavaScript subsets matter. Due to the permissive and versatile nature of the language, it is reasonable to select only the most solid stones to build a wall. But hey, why would we need to bother with a full programming language when we just need 6 characters? Here comes JSFuck by Martin Kleppe… JSFuck is an esoteric and educational programming style based on the atomic parts of JavaScript. It uses only six different characters to write and execute code. I know what you think: “6 characters? WTF!?“. Yes, JSFuck allows you to code using (, ), [, ], + and ! only. How is this possible? To understand what is going on behind JSFuck, we have to explain how JavaScript works with: Type conversion/coercion Truthy/falsy values Operator precedence/associativity Bracket notation Type conversion/coercionExplicit type conversionFor explicit type conversion in JavaScript, unary operators like + or ! may be used: + can convert the operand to a number ! can convert the operand to a boolean (and “negates” it) // MULTIPLE TYPESvar str = '', nb = 42, bool = true, arr = [], obj = &#123;&#125;;console.log(str, typeof str); // \"\" stringconsole.log(nb, typeof nb); // 42 numberconsole.log(bool, typeof bool); // true booleanconsole.log(arr, Array.isArray(arr)); // [] trueconsole.log(obj, typeof obj); // &#123;&#125; object// NUMBERSvar n_str = +str, n_nb = +nb, n_bool = +bool, n_arr = +arr, n_obj = +obj;console.log(n_str, typeof n_str); // 0 numberconsole.log(n_nb, typeof n_nb); // 42 numberconsole.log(n_bool, typeof n_bool); // 1 numberconsole.log(n_arr, typeof n_arr); // 0 numberconsole.log(n_obj, typeof n_obj); // NaN number// BOOLEANSvar b_str = !str, b_nb = !nb, b_bool = !bool, b_arr = !arr, b_obj = !obj;console.log(b_str, typeof b_str); // true booleanconsole.log(b_nb, typeof b_nb); // false booleanconsole.log(b_bool, typeof b_bool); // false booleanconsole.log(b_arr, typeof b_arr); // false booleanconsole.log(b_obj, typeof b_obj); // false boolean Implicit type conversion (coercion)There would be many things to say about type coercion in JavaScript… However, with JSFuck, we only need to understand why: []+[] is an empty string +[] is 0 true+false = 1 These three odd behaviors are linked to the same ambiguity: the + operator which can be used for concatenation (in a string context) and for addition/incrementation/conversion (in a numerical context). In fact, Array.prototype.toString() is called internally during an array-to-primitive conversion, and we know that its output is different from the one given by Object.prototype.toString(): it will not return something like [object Object], but a concatenation of all elements in the array with a comma as a separator. var arr = ['foo', 'bar', 'baz'];console.log(arr.toString()); // foo,bar,baz Of course, if the array is empty, Array.prototype.toString() returns an empty string. That is why []+[] gives an empty string: this operation is actually no more than a concatenation of empty strings after coercion! Moreover, when converted to a number, an empty string becomes 0. [object Object] is not an empty string and does not contain numbers, so it becomes NaN. Here is what happens (roughly) under the hood: console.log([].toString() + [].toString()); // \"\"console.log([].toString(), +[].toString()); // \"\" 0console.log(&#123;&#125;.toString(), +&#123;&#125;.toString()); // [object Object] NaN An operation with + where operands are booleans is not evaluated in a string context, but in a numerical context. This means booleans are coerced to numbers. true becomes 1 and false becomes 0. console.log(false + false); // 0console.log(true + false); // 1console.log(true + true); // 2 Truthy/Falsy valuesIn boolean expressions, JavaScript accepts booleans (true/false), but it also evaluates truthy and falsy values: An object (object literal, array, function, etc.) is always truthy undefined, null, NaN, 0 and the empty string are falsy function truthyOrFalsy(arg) &#123; arg ? console.log('truthy') : console.log('falsy');&#125;truthyOrFalsy(''); // falsytruthyOrFalsy('str'); // truthytruthyOrFalsy(0); // falsytruthyOrFalsy(1); // truthytruthyOrFalsy([]); // truthytruthyOrFalsy(&#123;&#125;); // truthyconsole.log(!'', !!''); // true falseconsole.log(!'str', !!'str'); // false trueconsole.log(!0, !!0); // true falseconsole.log(!1, !!1); // false trueconsole.log(![], !![]); // false trueconsole.log(!&#123;&#125;, !!&#123;&#125;); // false true Obviously, truthy values become true when they are converted to booleans with !! (double logical NOT or “NOT NOT”) and falsy values become false. Operator precedence and associativityJust like in math, operations must be performed in a specific order, following certain conventions. This order is determined by: Operator precedence Operator associativity Operator precedenceEach operator has its own priority. For example, we know that multiplication takes priority over addition and that parentheses allow us to override this natural priority. console.log(1 + 2 * 3); // 7console.log((1 + 2) * 3); // 9 Like most programming languages, JavaScript has many operators. The full reference of operator precedence is available on MDN. An interesting point is that the unary + has higher precedence than the binary +. // Conversions are performed BEFORE the additionconsole.log(+'41' + +true); // 42 Operator associativityUnfortunately, operator precedence cannot determine the “absolute” order of all operations. An operation can contain several operators that have the same precedence, so we need a clear direction (“left-to-right” or “right-to-left”). In math, we know that the order does not really matter to perform an addition: console.log(1000 + 300 + 37); // 1337console.log(300 + 1000 + 37); // 1337console.log(37 + 300 + 1000); // 1337 But it is much more problematic with subtraction: console.log(100 - 58); // 42console.log(58 - 100); // -42 An interesting point is that the unary + has “right-to-left” associativity, whereas the binary + has “left-to-right” associativity. Again, the full reference of operator associativity is available on MDN. We could also bring back the previous example: // Conversions are performed right-to-left// The addition is performed left-to-rightconsole.log(+'41' + +true); // 42 Bracket notationIn JavaScript, all objects have own and/or prototype properties. These properties can be accessed using the dot (.) notation or the bracket notation ([]). JSFuck uses bracket notation, which must not be confused with empty arrays… console.log(&#123;foo: 'Foo'&#125;.foo); // Fooconsole.log(&#123;foo: 'Foo'&#125;['foo']); // Fooconsole.log([].length); // 0console.log([]['length']); // 0console.log(/abc/g.flags); // gconsole.log(/abc/g['flags']); // gconsole.log(function fn() &#123;&#125;.name); // fnconsole.log(function fn() &#123;&#125;['name']); // fn JSFuck basicsJSFuck introduces itself with the following basics: false =&gt; ![] true =&gt; !![] undefined =&gt; [][[]] NaN =&gt; +[![]] 0 =&gt; +[] 1 =&gt; +!+[] 2 =&gt; !+[]+!+[] 10 =&gt; [+!+[]]+[+[]] Array =&gt; [] Number =&gt; +[] String =&gt; []+[] Boolean =&gt; ![] Function =&gt; [][&quot;filter&quot;] eval =&gt; [][&quot;filter&quot;][&quot;constructor&quot;]( CODE )() window =&gt; [][&quot;filter&quot;][&quot;constructor&quot;](&quot;return this&quot;)() With what we know about type conversion/coercion, truthy/falsy values, operator precedence/associativity and bracket notation, we can know explain this mess! false =&gt; ![][] is an array. JS arrays are objects and objects are always truthy. So if we negate a truthy value with a logical NOT, it becomes false. true =&gt; !![]![] is false, but !![] is equivalent to !false. So it is true. undefined =&gt; [][[]][] is an array. Each array has built-in properties. length is a valid one and could be accessed like so: [][&quot;length&quot;]. In this case, the array is empty and returns 0. But in our case, [] or &quot;&quot; is not a valid property of the array, so [][[]] obviously returns undefined. NaN =&gt; +[![]]![] is false, but [false] is truthy (this is an array containing a boolean). [false].toString() returns the string &quot;false&quot; and +&quot;false&quot; returns NaN. 0 =&gt; +[][].toString() gives an empty string and +&quot;&quot; gives 0. 1 =&gt; +!+[]+[] gives 0. 0 is falsy, so !0 gives true. +true gives 1. 2 =&gt; !+[]+!+[]!+[] is true because +[] is 0 and 0 is falsy (!0 is true). true+true = 2 because booleans are coerced to numbers when evaluated in a numerical context (+false is 0 and +true is 1). 10 =&gt; [+!+[]]+[+[]]Left part: +!+[] = 1, so [+!+[]] = [1].Right part: +[] = 0, so [+[]] = [0]. Concatenation:[1]+[0] is equivalent to [1].toString() + [0].toString() and returns &quot;10&quot;. Array =&gt; []An array literal (better alternative to new Array()). Array.isArray([]) = true. Number =&gt; +[]+[] = 0 and typeof +[] = number. String =&gt; []+[][]+[] is equivalent to [].toString() + [].toString(). It is actually a concatenation of empty strings and the result is an empty string. Boolean =&gt; ![][] is truthy, ![] is false. Function =&gt; [][&quot;filter&quot;][] is an array (instance of Array) and has access to Array.prototype methods. We can then access Array.prototype.filter (which is a function) using bracket notation. eval =&gt; [][&quot;filter&quot;][&quot;constructor&quot;]( CODE )()[][&quot;filter&quot;] is a function. In JavaScript, each function is an instance of Function and has access to Function.prototype properties. Function.prototype.constructor is one of these properties (this one is actually a reference to Function). Thus, [][&quot;filter&quot;][&quot;constructor&quot;] is an equivalent of Function. With or without new, Function() returns a new function. We could then make a simple addition like so: Function('a', 'b', 'return a + b')(3, 7) // returns 10 window =&gt; [][&quot;filter&quot;][&quot;constructor&quot;](&quot;return this&quot;)()[][&quot;filter&quot;][&quot;constructor&quot;] is Function. When the code is not in strict mode, this is generally window in regular functions. Here is an example: function foo() &#123; console.log(this); // window&#125;foo(); For the record, this result would be undefined in strict mode: function foo() &#123; 'use strict'; console.log(this); // undefined&#125;foo(); It could also be written like this: [][\"filter\"][\"constructor\"](\"'use strict'; console.log(this);\")() ChallengeTry to decrypt the following code. Don’t cheat, if you can… :P (!![]+[])[!+[]+!+[]+!+[]]+([][[]]+[])[+!+[]]+([][[]]+[])[!+[]+!+[]] Hints Identify the main operands Break it into small pieces The result is a string Good luck! Solution(!![]+[]) =&gt; (true+[]) =&gt; (&quot;true&quot;+&quot;&quot;) =&gt; (&quot;true&quot;) =&gt; &quot;true&quot;[!+[]+!+[]+!+[]] =&gt; [!0+!0+!0] =&gt; [true+true+true] =&gt; [1+1+1] =&gt; [3]+([][[]]+[]) =&gt; (undefined+[]) =&gt; (&quot;undefined&quot;+&quot;&quot;) =&gt; &quot;undefined&quot;[+!+[]] =&gt; [+!0] =&gt; [+true] =&gt; [1]+([][[]]+[]) =&gt; (undefined+[]) =&gt; (&quot;undefined&quot;+&quot;&quot;) =&gt; &quot;undefined&quot;[!+[]+!+[]] =&gt; [!0+!0] =&gt; [true+true] =&gt; [1+1] =&gt; [2]= &quot;true&quot;[3]+&quot;undefined&quot;[1]+&quot;undefined&quot;[2]= &quot;e&quot;+&quot;n&quot;+&quot;d&quot;= &quot;end&quot;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://badacadabra.github.io/categories/JavaScript/"}],"tags":[{"name":"ES5","slug":"ES5","permalink":"https://badacadabra.github.io/tags/ES5/"},{"name":"JSFuck","slug":"JSFuck","permalink":"https://badacadabra.github.io/tags/JSFuck/"}]}]}